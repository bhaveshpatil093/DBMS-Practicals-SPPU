DFS & BFS - Graph Traversal Explanation
Objective:
Implement DFS (Depth First Search) using recursion and BFS (Breadth First Search) on an undirected graph.

GRAPH STRUCTURE:
    0 --- 1 --- 2
    |     |     |
    3 --- 4 --- 5
    |
    6
    
Adjacency List Representation:
0 → [1, 3]
1 → [0, 2, 4]
2 → [1, 5]
3 → [0, 4, 6]
4 → [1, 3, 5]
5 → [2, 4]
6 → [3]

1. DFS (Depth First Search) - RECURSIVE
Algorithm:
javascriptfunction dfs(vertex) {
    if (visited[vertex]) return;
    
    visited[vertex] = true;
    result.push(vertex);
    
    // Recursively visit all neighbors
    for (neighbor of adjacencyList[vertex]) {
        if (!visited[neighbor]) {
            dfs(neighbor);  // Recursive call
        }
    }
}

How it works:
Start at vertex 0
Mark has visited
Recursively visit the first unvisited neighbor
Go DEEP before exploring siblings
Backtrack when no unvisited neighbors

Output: 0 → 1 → 2 → 5 → 4 → 3 → 6

2. BFS (Breadth First Search) - QUEUE
Algorithm:
javascriptfunction bfs(start) {
    queue = [start];
    visited[start] = true;
    
    while (queue is not empty) {
        vertex = queue.dequeue();
        result.push(vertex);
        
        // Add all unvisited neighbors to queue
        for (neighbor of adjacencyList[vertex]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                queue.enqueue(neighbor);
            }
        }
    }
}

How it works:
1. Start at vertex 0, add to the queue
2. Remove from queue, mark visited
3. Add all unvisited neighbors to the queue
4. Explore LEVEL BY LEVEL
5. Continue until queue empty

Output: 0 → 1 → 3 → 2 → 4 → 6 → 5

---

KEY DIFFERENCES:

| Feature | DFS | BFS |
|---------|-----|-----|
| Data Structure | Stack (Recursion) | Queue |
| Approach | Go deep first | Go level by level |
| Memory | Less memory | More memory |
| Use Case | Path finding, Cycle detection | Shortest path |
| Implementation | Recursive | Iterative |

---

VISUALIZATION:

DFS Traversal:

Start: 0
  ↓ (go deep)
  1
  ↓ (go deep)
  2
  ↓ (go deep)
  5
  ↓ (backtrack to 1)
  4
  ↓ (backtrack to 0)
  3
  ↓
  6

BFS Traversal:
Level 0: 0
Level 1: 1, 3
Level 2: 2, 4, 6
Level 3: 5

COMPLEXITY:
Time: O(V + E) - Visit all vertices and edges
Space: O(V) - Store visited array

Where:
V = Number of vertices
E = Number of edges


PYTHON CODE VERSION:
# DFS - Recursive
def dfs(graph, vertex, visited, result):
    visited[vertex] = True
    result.append(vertex)
    
    for neighbor in graph[vertex]:
        if not visited[neighbor]:
            dfs(graph, neighbor, visited, result)

# BFS - Queue
from collections import deque

def bfs(graph, start):
    visited = {start: True}
    queue = deque([start])
    result = []
    
    while queue:
        vertex = queue.popleft()
        result.append(vertex)
        
        for neighbor in graph[vertex]:
            if neighbor not in visited:
                visited[neighbor] = True
                queue.append(neighbor)
    
    return result

VIVA QUESTIONS:
Q1: What is DFS?
Depth-first search explores the graph by going as deep as possible before backtracking

Q2: DFS uses which data structure?
Stack (implemented via recursion)

Q3: What is BFS?
Breadth First Search explores the graph level by level

Q4: BFS uses which data structure?
Queue

Q5: Which is better for the shortest path?
BFS (finds the shortest path in an unweighted graph)

Q6: Time complexity?
Both: O(V + E)

APPLICATIONS:

DFS:
Path finding
Cycle detection
Topological sorting
Maze solving

BFS:
Shortest path (unweighted)
Social networks (friend suggestions)
Web crawlers
GPS navigation
